# 2020-2021学年第2学期
# 实 验 报 告

![zucc](images\\zucc.png "zucc")

* 课程名称:编程语言原理与编译
* 实验项目:期末大作业
* 专业班级:<u>计算机2004</u>
* 学生学号:<u>32001056 &nbsp;&nbsp; 32001108</u>
* 学生姓名:<u>吴宝俊 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 杨文韬</u>
* 实验指导教师:郭鸣

# 实验内容
### 成员信息

| 姓名 | 学号 | 班级 | 任务 | 权重 |
| --- | --- | --- | --- | --- |
|吴宝俊|32001056|计算机2004|编码|0.95|
|杨文韬|32001108|计算机2004|编码|0.95|

### 成员代码提交日志


### 项目自评等级:(1-5)

| 词法 | 词法 | 备注 |
| --- | --- | --- |
|注释 // /**/|||
|字符串常量 单引号' ' 双引号 "" 三引号 '''|||
|数值常量 0b0101， 八进制0o777 十六0xFFDA|||
|语法|||
|if的多种方式 switch case|||
|循环 for / while / do while/ until|||
|for in 表达式|||
|语义|||
|动态作用域，静态作用域|||
|闭包支持||
|模式匹配支持|||
|中间代码生成 AST，四元式，三元式，llvm|||
|生成器 generator, yield|||

### 项目说明
1. **for模块实现**

修改了Absyn.fs文件39行

```
  | For of expr * expr * expr * stmt (* For                         *)
```
修改了CLex.fsl文件32行
```
| "for"     -> FOR
```
修改了Comp.fs文件190行
```
| For (e1, e2, e3, body) ->
    let labbegin = newLabel()
    let labtest  = newLabel()

    cExpr e1 varEnv funEnv @ [INCSP -1]
        @ [GOTO labtest; Label labbegin]
            @ cStmt body varEnv funEnv
                @ cExpr e3 varEnv funEnv @ [INCSP -1]
                    @ [Label labtest]
                        @ cExpr e2 varEnv funEnv @ [IFNZRO labbegin]
```
修改了CPar.fsy文件20行
```
%token CHAR ELSE IF INT NULL PRINT PRINTLN RETURN VOID WHILE FOR
```
修改了Interp.fs文件292行

```
    | For (e1, e2, e3, body) ->
    let (v, store1) = eval e1 locEnv gloEnv store
    let rec loop store1 = 
        let (v,store2) = eval e2 locEnv gloEnv store1
        if v<>0 then loop(snd(eval e3 locEnv gloEnv (exec body locEnv gloEnv store2)))
        else store2

    loop store1
```

测试代码存放于test\\forTest.c
```
void main (int n){
    int a;
    for (a = 0;a < n;a = a + 1){
        print a;
    }
}
```
测试成果
![forTest](images\\forTest.png "forTest")

2.**i++,i--,++i,--i模块实现**

修改了Absyn.fs文件26行
```
| Prim3 of string * access         (* i++ i-- ++i i--             *)
```

修改了CLex.fsl文件75、76行

```
  | "++"            { PREINC }
  | "--"            { PREDEC }
```

修改了CPar.fsy文件21行

```
%token PLUS MINUS TIMES DIV MOD PREINC PREDEC
```

修改了Comp.fs文件266行
```
    | Prim3 (ope, e) ->
        (match ope with
            | "I++" ->
                cAccess e varEnv funEnv
                 @[ DUP;LDI;SWAP;DUP;LDI;CSTI 1; ADD;STI;INCSP -1]
            | "I--" ->
                cAccess e varEnv funEnv
                 @[ DUP;LDI;SWAP;DUP;LDI;CSTI -1; ADD;STI;INCSP -1]
            | "++I" ->
                cAccess e varEnv funEnv
                 @[ DUP;LDI; CSTI 1; ADD;STI]
            | "--I" ->
                cAccess e varEnv funEnv
                 @[ DUP;LDI; CSTI -1; ADD;STI]
            | _ -> raise (Failure "unknown primitive 4")
            )
```

修改了Interp.fs文件
```
    | Prim3(ope, acc) ->
        let (loc, store1) = access acc locEnv gloEnv store
        let (i1) = getSto store1 loc
        match ope with
            | "I++" ->
                let res = i1 + 1
                i1, setSto store1 loc res
            | "I--" ->
                let res = i1 - 1
                i1, setSto store1 loc res
            | "++I" ->
                let res = i1 + 1
                res, setSto store1 loc res
            | "--I" ->
                let res = i1 - 1
                res, setSto store1 loc res
            | _ -> failwith ("unknown primitive " + ope)
```

测试代码存放于test\\++Test2.c
```
void main(int n)
{
  print n;
  n++;
  ++n;
  print n;
  n=5;
  n--;
  --n;
  print n;
}
```

测试成果
![++Test](images\\1++Test.png)


3.**dowhile模块实现**

Absyn.fs

```
  | DoWhile of stmt * expr           (* Do While                    *)
```

CLex.fsl

```
    | "do"      -> DO
```

CPar.fsy

```
  	| DO StmtM WHILE LPAR Expr RPAR SEMI  { DoWhile($2, $5)      }
  
%token CHAR ELSE IF INT NULL PRINT PRINTLN RETURN VOID WHILE FOR DO
```

Comp.fs

```
    | DoWhile (body, e) ->
        let labbegin = newLabel ()
        let labtest = newLabel ()

        cStmt body varEnv funEnv
            @[ GOTO labtest ]
                @[ Label labbegin ]
                @ cStmt body varEnv funEnv
                @ [ Label labtest ]
                @ cExpr e varEnv funEnv
                @ [ IFNZRO labbegin ]
```

Interp.fs

```
    | DoWhile (body, e) ->
        let rec loop store1 =
            let (v, store2) = eval e locEnv gloEnv store1
            if v <> 0 then
                loop (exec body locEnv gloEnv store2)
            else
                store2
        
        loop (exec body locEnv gloEnv store)
```

测试代码存放于test\\dowhileTest.c

```
void main (int n){
  int a;
  a=5;
  do
  {
    a=a+1;
    print a;
  } while (a<=n);
  
}
```

测试成果

![dowhileTest](images\\dowhileTest.png)



4.**三元运算符模块实现**

Absyn.fs

```
  | Prim4 of expr * expr * expr      (*  ?:                         *)
```

CLex.fsl

```
  | '?'             { QST  } 
  | ':'             { COLON  }
```

CPar.fsy

```
  | Expr QST Expr COLON Expr            { Prim4($1,$3,$5)     }
```

Interp.fs

```
    | Prim4 ( e1, e2, e3) -> 
        let (i1, store1) = eval e1 locEnv gloEnv store
        let (i2, store2) = eval e2 locEnv gloEnv store1
        let (i3, store3) = eval e2 locEnv gloEnv store2
        let res = if i1<>0 then i2 else i3
        (res, store3)

```

测试代码存放于test\\sanyuanTest.c

```
void main()
{
  int x;
  int y;
  int n;
  x=5;
  y=10;
  n = (x > y) ? x : y;
  print n;
}
```

![sanyuanTest](images\\sanyuanTest.png)

4.**+=、-=、*=、/=、%=模块实现**

Absyn.fs

```
  | AssignPrim of string * access * expr (* += -= *= /= %=             *)
```

CLex.fsl

```
  | "+="            { PLUSAS }
  | "-="            { MINUSAS }
  | "*="            { TIMESAS }
  | "/="            { DIVAS }
  | "%="            { MODAS }
```

CPar.fsy

```
  %token PLUS MINUS TIMES DIV MOD PREINC PREDEC PLUSAS MINUSAS TIMESAS DIVAS MODAS
  | Access PLUSAS Expr                  { AssignPrim("+=", $1, $3) } 
  | Access MINUSAS Expr                 { AssignPrim("-=", $1, $3) } 
  | Access TIMESAS Expr                 { AssignPrim("*=", $1, $3) }
  | Access DIVAS Expr                   { AssignPrim("/=", $1, $3) }
  | Access MODAS Expr                   { AssignPrim("%=", $1, $3) }
```

Comp.fs

```
    | AssignPrim (ope, e1, e2) ->
        cAccess e1 varEnv funEnv
         @ [DUP; LDI]
            @ cExpr e2 varEnv funEnv
                @ (match ope with
                    | "+=" -> [ ADD; STI ]
                    | "-=" -> [ SUB; STI ]
                    | "*=" -> [ MUL; STI ]
                    | "/=" -> [ DIV; STI ]
                    | "%=" -> [ MOD; STI ]
                    | _ -> raise (Failure "unknown AssignPrim"))

```

Interp.fs

```
    | AssignPrim(ope, acc, e) ->
        let (loc, store1) = access acc locEnv gloEnv store
        let tmp = getSto store1 loc
        let (res, store2) = eval e locEnv gloEnv store1
        let num = 
            match ope with
            | "+=" ->  tmp + res
            | "-=" ->  tmp - res
            | "*=" ->  tmp * res
            | "/=" ->  tmp / res
            | "%=" ->  tmp % res
            | _ -> failwith ("unknown primitive " + ope)
        (num, setSto store2 loc num)
```

测试代码存放于test\\assignTest.c

```
void main(int n)
{
  int a;
  a = 10;
  a += n;
  print a;
  a = 10;
  a -= n;
  print a;
  a = 10;
  a *= n;
  print a;
  a = 10;
  a /= n;
  print a;
  a = 10;
  a %= n;
  print a;
}
```

测试成果

![assignTest](images\\assignTest.png)


5.**break实现**

Absyn.fs
```
| Break                            (* Break                       *)
```

CLex.fsl
```
| "break"   -> BREAK
```

CPar.fsy
```
  | BREAK SEMI                          { Break                }
```

Comp.fs
<br>在每个涉及到break的模块的comp.fs均有改变, 已经直接反映到对应的实验报告代码中
<br>此处仅存放break主体以及为了写break添加的用list模拟的栈
```
// 存储labend的栈
let mutable endlist : label list = []
// 存储labbegin的栈
let mutable beglist : label list = []

// endlist顶端元素入栈
let rec pushendlist labs =
    endlist <- labs :: endlist
    []

// beglist顶端元素入栈
let rec pushbeglist labs =
    beglist <- labs :: beglist
    []

// endlist顶端元素出栈
let rec popendlist () =
    endlist <-
        match endlist with
            | lab :: tr -> tr
            | []        -> failwith "Error: empty loop"
    []

// beglist顶端元素出栈
let rec popbeglist () =
    beglist <-
        match beglist with
            | lab :: tr -> tr
            | []        -> failwith "Error: empty loop"
    []

// 获取labs栈顶元素(要记得pop)
let rec toplab labs =
    match labs with
        | lab :: tr -> lab
        | []        -> failwith "Error: unknown break/continue"
        


    | Break ->
        let labend = toplab endlist
        [GOTO labend]
```

Interp.fs
```
    | Break -> store
```

测试代码存放于test\\breakTest.c

```
void main (int n){
    int a;
    a = n;
    int b;
    b = 0;
    while (a < 11) {
        print a;
        while (b < 3){
            print -1;
            break;
            b = b + 1;
        }
        a = a + 1;
        if(a == 9){
            break;
        }
    }

    for (a;a > 5;a = a - 1){
        print a;
        if (a == 7){
            print a;
            break;
        }
    }
}
```

测试成果

![breakTest.png](images\\breakTest.png)

6.**switchcase实现**

Absyn.fs

```
  | Switch of expr * stmt list       (* Switch                      *)
  | Case of expr * stmt              (* Case                        *)
  | Default of stmt                  (* Default                     *)
```

CLex.fsl

```
    | "switch"  -> SWITCH
    | "case"    -> CASE
    | "default" -> DEFAULT
```

CPar.fsy

```
  | SWITCH LPAR Expr RPAR LBRACE CaseList RBRACE { Switch($3, $6)       }
  %token CHAR ELSE IF INT NULL PRINT PRINTLN RETURN VOID WHILE FOR DO BREAK SWITCH CASE DEFAULT
  CaseList:
                        { [] }
  | CaseDec             { [$1] }
  | CaseDec CaseList    { $1 :: $2 }
  | DEFAULT COLON Stmt  { [Default($3)] }
;

CaseDec:
  CASE Expr COLON Stmt  { Case($2, $4)  }
;
```

Comp.fs

```
    | Switch(e, cases) ->
        let rec searchcases c =
            match c with
            | Case (e, body) :: tail ->
                let labend = newLabel ()
                let labfin = newLabel ()

                [DUP]
                    @ cExpr e varEnv funEnv
                        @ [EQ]
                            @ [ IFZERO labend ]
                                @ cStmt body varEnv funEnv
                                    @ [ GOTO labfin ]
                                        @ [ Label labend ]
                                            @ searchcases tail
                                                @ [ Label labfin ]
            | Default body :: [] ->
                cStmt body varEnv funEnv
            | [] -> []

        cExpr e varEnv funEnv
            @ searchcases cases
                @ [ INCSP -1 ]

    | Case (e, body) -> cStmt body varEnv funEnv
    | Default (body) -> cStmt body varEnv funEnv
  
```

Interp.fs

```
    | Switch(e, body) ->
        let (v, store0) = eval e locEnv gloEnv store
        let rec carry list = 
            match list with
            | Case(e1, body1) :: next ->
                let (v1, store1) = eval e1 locEnv gloEnv store0
                if v1 = v then exec body1 locEnv gloEnv store1
                else carry next
            | Default(body) :: over ->
                exec body locEnv gloEnv store0
            | [] -> store0
            | _ -> store0

        (carry body)

    | Case (e, body) -> exec body locEnv gloEnv store
    | Default(body) -> exec body locEnv gloEnv store
```

测试代码存放于test\\switchcaseTest.c

```
void main()
{
  int a;
  a = 3;
  switch (a)
  {
  case 1:
    print a;
  case 2:
    print a+1;
  default:
    print (a*a);
  }
}
```

测试成果：

![switchcaseTest](images\\switchcaseTest.png)


7.**continue实现**

Absyn.fs
```
  | Continue                         (* Continue                    *)
```

CLex.fsl
```
  | "continue"-> CONTINUE
```

CPar.fsy
```
%token CHAR ELSE IF INT NULL PRINT PRINTLN RETURN VOID WHILE FOR DO BREAK SWITCH CASE DEFAULT CONTINUE

  | CONTINUE SEMI                       { Continue             }
```

Comp.fs
```
    | Continue ->
        let lablist = dellab lablist
        let labbegin = headlab lablist
        [GOTO labbegin]
```

Interp.fs
```
    | Continue -> store
```

测试代码存放于test\\continueTest.c

```
void main (int n){
    int a;
    a = n;
    while (a < 10) {
        if (a == 8) {
            a = a + 1;
            continue;
        }
        print a;
        a = a + 1;
    }
}
```

测试成果

![continueTest.png](images\\continueTest.png)

8. **until模块实现**

Absyn.fs
```
  | Until of expr * stmt             (* Until                       *)
```
CLex.fsl
```
    | "until"   -> UNTIL
```
Comp.fs
```
    | Until (e, body) ->
        let labbegin = newLabel ()
        let labtest = newLabel ()
        let labend = newLabel ()
        lablist <- [labend; labtest; labbegin]
        [ GOTO labtest; Label labbegin ]
        @ cStmt body varEnv funEnv
          @ [ Label labtest ]
            @ cExpr e varEnv funEnv @ [ IFZERO labbegin; Label labend ]
```
CPar.fsy
```
%token CHAR ELSE IF INT NULL PRINT PRINTLN RETURN VOID WHILE FOR DO BREAK SWITCH CASE DEFAULT CONTINUE UNTIL

  | UNTIL LPAR Expr RPAR StmtM          { Until($3, $5)        }

  | UNTIL LPAR Expr RPAR StmtU          { Until($3, $5) 
```
Interp.fs
```
    | Until (e, body) ->
        //定义 Until循环辅助函数 loop
        let rec loop store1 =
            //求值 循环条件,注意变更环境 store
            let (v, store2) = eval e locEnv gloEnv store1
            // 继续循环
            if v <> 0 then
                store2 //退出循环返回 环境store2
            else
                loop (exec body locEnv gloEnv store2)
        loop store
```

测试代码存放于test\\untilTest.c
```
void main (int n){
    int a;
    a = n;
    until(a > 10){
        print a;
        a = a + 1;
    }
}
```
测试成果
![untilTest](images\\untilTest.png "untilTest")




### 独立开发了 xx 模块

   - 解决 xxx 问题1， 关键代码与步骤如下
     - ...
     - ...

### 心得体会
   - 大项目开发过程心得
     - 遇到哪些困难，经历哪里过程，有哪些收获
   - 本课程建议
     - 课程难度方面，进度方面，课程内容，授课方式等，给出你的意见