# 2020-2021学年第2学期
# 实 验 报 告

![zucc](images\\zucc.png "zucc")

* 课程名称:编程语言原理与编译
* 实验项目:期末大作业
* 专业班级:<u>计算机2004</u>
* 学生学号:<u>32001056 &nbsp;&nbsp; 32001108</u>
* 学生姓名:<u>吴宝俊 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 杨文韬</u>
* 实验指导教师:郭鸣

# 实验内容
### 成员信息

| 姓名 | 学号 | 班级 | 任务 | 权重 |
| --- | --- | --- | --- | --- |
|吴宝俊|32001056|计算机2004|编码|0.95|
|杨文韬|32001108|计算机2004|编码|0.95|

### 成员代码提交日志


### 项目自评等级:(1-5)

| 词法 | 词法 | 备注 |
| --- | --- | --- |
|注释 // /**/|||
|字符串常量 单引号' ' 双引号 "" 三引号 '''|||
|数值常量 0b0101， 八进制0o777 十六0xFFDA|||
|语法|||
|if的多种方式 switch case|||
|循环 for / while / do while/ until|||
|for in 表达式|||
|语义|||
|动态作用域，静态作用域|||
|闭包支持||
|模式匹配支持|||
|中间代码生成 AST，四元式，三元式，llvm|||
|生成器 generator, yield|||

### 项目说明
1. **for模块实现**

修改了Absyn.fs文件39行

```
  | For of expr * expr * expr * stmt (* For                         *)
```
修改了CLex.fsl文件32行
```
| "for"     -> FOR
```
修改了Comp.fs文件190行
```
| For (e1, e2, e3, body) ->
    let labbegin = newLabel()
    let labtest  = newLabel()

    cExpr e1 varEnv funEnv @ [INCSP -1]
        @ [GOTO labtest; Label labbegin]
            @ cStmt body varEnv funEnv
                @ cExpr e3 varEnv funEnv @ [INCSP -1]
                    @ [Label labtest]
                        @ cExpr e2 varEnv funEnv @ [IFNZRO labbegin]
```
修改了CPar.fsy文件20行
```
%token CHAR ELSE IF INT NULL PRINT PRINTLN RETURN VOID WHILE FOR
```
修改了Interp.fs文件292行

```
    | For (e1, e2, e3, body) ->
    let (v, store1) = eval e1 locEnv gloEnv store
    let rec loop store1 = 
        let (v,store2) = eval e2 locEnv gloEnv store1
        if v<>0 then loop(snd(eval e3 locEnv gloEnv (exec body locEnv gloEnv store2)))
        else store2

    loop store1
```

测试代码存放于test\\forTest.c
```
void main (int n){
    int a;
    for (a = 0;a < n;a = a + 1){
        print a;
    }
}
```
测试成果
![forTest](images\\forTest.png "forTest")

2.**i++,i--,++i,--i模块实现**

修改了Absyn.fs文件26行
```
| Prim3 of string * access         (* i++ i-- ++i i--             *)
```

修改了CLex.fsl文件75、76行

```
  | "++"            { PREINC }
  | "--"            { PREDEC }
```

修改了CPar.fsy文件21行

```
%token PLUS MINUS TIMES DIV MOD PREINC PREDEC
```

修改了Comp.fs文件266行
```
    | Prim3 (ope, e) ->
        (match ope with
            | "I++" ->
                cAccess e varEnv funEnv
                 @[ DUP;LDI;SWAP;DUP;LDI;CSTI 1; ADD;STI;INCSP -1]
            | "I--" ->
                cAccess e varEnv funEnv
                 @[ DUP;LDI;SWAP;DUP;LDI;CSTI -1; ADD;STI;INCSP -1]
            | "++I" ->
                cAccess e varEnv funEnv
                 @[ DUP;LDI; CSTI 1; ADD;STI]
            | "--I" ->
                cAccess e varEnv funEnv
                 @[ DUP;LDI; CSTI -1; ADD;STI]
            | _ -> raise (Failure "unknown primitive 4")
            )
```

修改了Interp.fs文件
```
    | Prim3(ope, acc) ->
        let (loc, store1) = access acc locEnv gloEnv store
        let (i1) = getSto store1 loc
        match ope with
            | "I++" ->
                let res = i1 + 1
                i1, setSto store1 loc res
            | "I--" ->
                let res = i1 - 1
                i1, setSto store1 loc res
            | "++I" ->
                let res = i1 + 1
                res, setSto store1 loc res
            | "--I" ->
                let res = i1 - 1
                res, setSto store1 loc res
            | _ -> failwith ("unknown primitive " + ope)
```

测试代码存放于test\\++Test2.c
```
void main(int n)
{
  print n;
  n++;
  ++n;
  print n;
  n=5;
  n--;
  --n;
  print n;
}
```

测试成果
![++Test](images\\1++Test.png)


3.**dowhile模块实现**

Absyn.fs

```
  | DoWhile of stmt * expr           (* Do While                    *)
```

CLex.fsl

```
    | "do"      -> DO
```

CPar.fsy

```
  	| DO StmtM WHILE LPAR Expr RPAR SEMI  { DoWhile($2, $5)      }
  
%token CHAR ELSE IF INT NULL PRINT PRINTLN RETURN VOID WHILE FOR DO
```

Comp.fs

```
    | DoWhile (body, e) ->
        let labbegin = newLabel ()
        let labtest = newLabel ()

        cStmt body varEnv funEnv
            @[ GOTO labtest ]
                @[ Label labbegin ]
                @ cStmt body varEnv funEnv
                @ [ Label labtest ]
                @ cExpr e varEnv funEnv
                @ [ IFNZRO labbegin ]
```

Interp.fs

```
    | DoWhile (body, e) ->
        let rec loop store1 =
            let (v, store2) = eval e locEnv gloEnv store1
            if v <> 0 then
                loop (exec body locEnv gloEnv store2)
            else
                store2
        
        loop (exec body locEnv gloEnv store)
```

测试代码存放于test\\dowhileTest.c

```
void main (int n){
  int a;
  a=5;
  do
  {
    a=a+1;
    print a;
  } while (a<=n);
  
}
```

测试成果

![dowhileTest](images\\dowhileTest.png)



4.**三元运算符模块实现**

Absyn.fs

```
  | Prim4 of expr * expr * expr      (*  ?:                         *)
```

CLex.fsl

```
  | '?'             { QST  } 
  | ':'             { COLON  }
```

CPar.fsy

```
  | Expr QST Expr COLON Expr            { Prim4($1,$3,$5)     }
```

Interp.fs

```
    | Prim4 ( e1, e2, e3) -> 
        let (i1, store1) = eval e1 locEnv gloEnv store
        let (i2, store2) = eval e2 locEnv gloEnv store1
        let (i3, store3) = eval e2 locEnv gloEnv store2
        let res = if i1<>0 then i2 else i3
        (res, store3)

```

测试代码存放于test\\sanyuanTest.c

```
void main()
{
  int x;
  int y;
  int n;
  x=5;
  y=10;
  n = (x > y) ? x : y;
  print n;
}
```

![sanyuanTest](images\\sanyuanTest.png)

4.**+=、-=、*=、/=、%=模块实现**

Absyn.fs

```
  | AssignPrim of string * access * expr (* += -= *= /= %=             *)
```

CLex.fsl

```
  | "+="            { PLUSAS }
  | "-="            { MINUSAS }
  | "*="            { TIMESAS }
  | "/="            { DIVAS }
  | "%="            { MODAS }
```

CPar.fsy

```
  %token PLUS MINUS TIMES DIV MOD PREINC PREDEC PLUSAS MINUSAS TIMESAS DIVAS MODAS
  | Access PLUSAS Expr                  { AssignPrim("+=", $1, $3) } 
  | Access MINUSAS Expr                 { AssignPrim("-=", $1, $3) } 
  | Access TIMESAS Expr                 { AssignPrim("*=", $1, $3) }
  | Access DIVAS Expr                   { AssignPrim("/=", $1, $3) }
  | Access MODAS Expr                   { AssignPrim("%=", $1, $3) }
```

Comp.fs

```
    | AssignPrim (ope, e1, e2) ->
        cAccess e1 varEnv funEnv
         @ [DUP; LDI]
            @ cExpr e2 varEnv funEnv
                @ (match ope with
                    | "+=" -> [ ADD; STI ]
                    | "-=" -> [ SUB; STI ]
                    | "*=" -> [ MUL; STI ]
                    | "/=" -> [ DIV; STI ]
                    | "%=" -> [ MOD; STI ]
                    | _ -> raise (Failure "unknown AssignPrim"))

```

Interp.fs

```
    | AssignPrim(ope, acc, e) ->
        let (loc, store1) = access acc locEnv gloEnv store
        let tmp = getSto store1 loc
        let (res, store2) = eval e locEnv gloEnv store1
        let num = 
            match ope with
            | "+=" ->  tmp + res
            | "-=" ->  tmp - res
            | "*=" ->  tmp * res
            | "/=" ->  tmp / res
            | "%=" ->  tmp % res
            | _ -> failwith ("unknown primitive " + ope)
        (num, setSto store2 loc num)
```

测试代码存放于test\\assignTest.c

```
void main(int n)
{
  int a;
  a = 10;
  a += n;
  print a;
  a = 10;
  a -= n;
  print a;
  a = 10;
  a *= n;
  print a;
  a = 10;
  a /= n;
  print a;
  a = 10;
  a %= n;
  print a;
}
```

测试成果

![assignTest](images\\assignTest.png)


5.**break实现**

Absyn.fs
```
| Break                            (* Break                       *)
```

CLex.fsl
```
| "break"   -> BREAK
```

CPar.fsy
```
  | BREAK SEMI                          { Break                }
```

Comp.fs
```
let mutable lablist : label list = []

let rec headlab labs =
    match labs with
        | lab :: tr -> lab
        | []        -> failwith "Error: unknown break"

    | Break -> 
        let labend = headlab lablist
        [GOTO labend]
```

Interp.fs
```
    | Break -> store
```

测试代码存放于test\\breakTest.c

```
void main (int n){
    int a;
    a = n;
    while (a < 10) {
        print a;
        if (a == 2) {
            print a;
            break;
        }
        a = a + 1;
    }
}
```

测试成果

![breakTest.png](images\\breakTest.png)




### 独立开发了 xx 模块

   - 解决 xxx 问题1， 关键代码与步骤如下
     - ...
     - ...

### 心得体会
   - 大项目开发过程心得
     - 遇到哪些困难，经历哪里过程，有哪些收获
   - 本课程建议
     - 课程难度方面，进度方面，课程内容，授课方式等，给出你的意见